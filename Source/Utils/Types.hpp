///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <algorithm>
#include <memory>
#include <string>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <vector>
#include <array>
#include <optional>
#include <filesystem>
#include <stack>
#include <thread>
#include <variant>
#include <mutex>
#include <functional>
#include <istream>
#include <fstream>
#include <tuple>
#include <any>
#include <queue>
#include <iostream>

///////////////////////////////////////////////////////////////////////////////
using FAny = std::any;

///////////////////////////////////////////////////////////////////////////////
using FOfStream = std::ofstream;
using FIfStream = std::ifstream;

///////////////////////////////////////////////////////////////////////////////
using FPath = std::filesystem::path;

///////////////////////////////////////////////////////////////////////////////
using FThread = std::thread;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TQueue = std::queue<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename R> using TFunction = std::function<R>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TAtomic = std::atomic<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TStack = std::stack<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename... Ts> using TVariant = std::variant<Ts...>;

///////////////////////////////////////////////////////////////////////////////
template <typename T, typename U> using TMap = std::map<T, U>;
template <typename T, typename U> using TUnorderedMap = std::unordered_map<T, U>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TSet = std::set<T>;
template <typename T> using TUnorderedSet = std::unordered_set<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T, typename U> using TPair = std::pair<T, U>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TOptional = std::optional<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TSharedPtr = std::shared_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TWeakPtr = std::weak_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TUniquePtr = std::unique_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using TVector = std::vector<T>;

///////////////////////////////////////////////////////////////////////////////
typedef unsigned char FUint8;
typedef unsigned short FUint16;
typedef unsigned int FUint32;
typedef unsigned long FUint64;

///////////////////////////////////////////////////////////////////////////////
template <typename T, FUint64 S> using TArray = std::array<T, S>;

///////////////////////////////////////////////////////////////////////////////
template <typename... Ts> using TTuple = std::tuple<Ts...>;

///////////////////////////////////////////////////////////////////////////////
typedef signed char FInt8;
typedef signed short FInt16;
typedef signed int FInt32;
typedef signed long FInt64;

///////////////////////////////////////////////////////////////////////////////
typedef unsigned char FByte;

///////////////////////////////////////////////////////////////////////////////
using FMutex = std::mutex;

///////////////////////////////////////////////////////////////////////////////
using FString = std::string;

///////////////////////////////////////////////////////////////////////////////
using FStringStream = std::stringstream;
